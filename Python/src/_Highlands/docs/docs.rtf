{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red102\green177\blue50;
\red0\green170\blue0;\red0\green0\blue0;\red85\green142\blue40;\red102\green177\blue50;}
{\*\expandedcolortbl;;\csgray\c0;\csgray\c100000;\cssrgb\c46532\c73327\c25364;
\csgenericrgb\c0\c66667\c0;\cssrgb\c0\c0\c0;\cssrgb\c39975\c61335\c20601;\cssrgb\c46532\c73327\c25364;}
\paperw11900\paperh16840\margl1440\margr1440\vieww24600\viewh7300\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \cb3 \CocoaLigature0 68.66.241.111\

\f1\fs24 \cf0 \cb1 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 Server\
\
The server uses 
\f2 http.server.HTTPServer 
\f1 to handle all client requests.  The HTTPServer library uses a callback to handle client requests (in our case the handler is called: "Handler").\
Most client requests use a GET request that contains a URL to determine what the server should send back to the client.  The exception is when the client sends the server the results of the survey when the client uses a POST.  The choice of GET and POST is arbitrary and initially I decided to use GET for the request of the Questions and POST to return the results.  As the application expanded I decided to use GET for all subsequent requests.\
\
The server contains a lengthy multiple if statement to separate GET reqests.  Currently the following URLs are used:\
\cf4     
\i questions			- send list of [QuestionNo, Section, Question, Type, Autofill] tuples\
    options				- send list of [Option1, Option2, Option3, ...]\
\pard\pardeftab720\partightenfactor0

\i0 \cf4     
\i emails-and-clients	- return a pair of lists: [email1, email2, ...], [client1, client2, ...]
\i0 \
    
\i chart-data			- return a dictionary of each database record.  Each key is of the form: section, client, <email>, uuid.  Each value is sum of marks for the database record
\i0 \
    
\i piechart-data		- return ...\
\pard\pardeftab720\partightenfactor0
\cf4     piechart-data2		- return ...\
\pard\pardeftab720\partightenfactor0

\i0 \cf4     
\i table-data			- return ...\
    checkbox-data		- return ...\
    scatter-data		- return ...\

\i0     
\i piechart-questions-options  - return ...\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\i0 \cf0 Additionally the client can request a file resource by giving the name of the file as the URL.  For example:\
\cf4     
\i favicon.ico\
    images/highlands.png\cf5 \

\i0 \cf6 For all resources it is important the server returns the correct MIME type, otherwise the browser may render the resource incorrectly (see getMimeType and sendHeaders).\
\
\pard\pardeftab720\sl280\partightenfactor0
\cf6 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 During development, some of the Python files were getting very long, so I decided to split them up.\'a0 The best way of doing that is to create a set of class files:\

\i \cf4 \'a0\'a0\'a0 excel.py\
\'a0\'a0\'a0 chart.py\
\'a0\'a0\'a0 myglobals.py\
\'a0\'a0\'a0 scatter.py\cf6 \

\i0 etc.\'a0 I then instantiate one object for each of the classes in any file that needs to use the functionality of the class.\'a0 For example, in server.py:\

\i \cf4 \'a0\'a0\'a0 # import class files\
\'a0\'a0\'a0 from myglobals import MyGlobals\
\'a0\'a0\'a0 from checkbox import Checkbox\
\'a0\'a0\'a0 from scatter import Scatter\
\'a0\'a0\'a0 from radio import Radio\
\'a0\'a0\'a0 from chart import Chart\
\'a0\'a0\'a0 from excel import Excel\
\'a0\'a0\'a0 from table import Table\
\
\'a0\'a0\'a0 # create an object for each class\
\'a0\'a0\'a0 checkbox = Checkbox()\
\'a0\'a0\'a0 scatter = Scatter()\
\'a0\'a0\'a0 radio = Radio()\
\'a0\'a0\'a0 chart = Chart()\
\'a0\'a0\'a0 xl = Excel()\
\'a0\'a0\'a0 table = Table()\

\i0 \cf7 \
\cf6 Each time you create an object in Python the __init__() method is called.\'a0 After that no methods are called until a client request is sent to the server.\'a0 For example, the client will make a request with the URL: "piechart-data2" and the server has a massive if statement to process requests (inside doGET()) and half way down is he code:\
\
    
\i \cf4 elif(fileName == "piechart-data2"):\
\'a0\'a0\'a0\'a0    sendHeaders()\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0jsonString = json.dumps(radio.getPieChartData2())\
\'a0
\i0 \cf6 \
The server sends back the headers to the browser to say it received the request and then calls "radio.getPieChartData2()".\'a0 The radio object was instantiated earlier, so we just call the method "getPieChartData2().\'a0 If the code was smaller I would have just had a function called getPieChartData2 (that's how I did do it originally), but its easier to use a method because the code is in a different file and Python doesn't allow global variables across files.\'a0 So if you put a break point on the first line of getPieChartData2 and then refresh the browser pie charts you will hit the breakpoint.\'a0 When the method returns it has all the data the client needs as a JSON string.\'a0 However, we can't send JSON strings directly to the client from Python web servers - it needs to be converted to bytes first.  Hence the code fragment:\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\pard\pardeftab720\partightenfactor0

\i \cf4         jsonAsBytes = jsonString.encode("UTF-8")\
        self.wfile.write(jsonAsBytes)\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 \
\pard\pardeftab720\sl280\partightenfactor0

\i0 \cf6 \
Client\
\
The client can operate in two modes dependent on which URL is used.  The URL:\
\cf4     http://<server>:<port>/client.html\
\cf6 is used to start the survey of questions.  The URL\
\pard\pardeftab720\sl280\partightenfactor0
\cf4 \outl0\strokewidth0     http://<server>:<port>/client.html?charts\
\pard\pardeftab720\sl280\partightenfactor0
\cf6 \outl0\strokewidth0 \strokec6 is used to see a graphical representation of the results of the surveys.\
\
The client code starts with client.html.  The file contains the initial html for the client and the top level javascript code.  As can be seen by inspecting this file, the client is using JQuery libraries to perform the bulk of the basic scripting and the C3 javascript library for all the charts.  Note that C3 calls the D3 javascipt library, so both are loaded.  It is important to use compatible C3 and D3 libraries.  I'm using:\
\pard\pardeftab720\partightenfactor0

\i \cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0     d3-5.5.0/d3.min.js\
    c3-0.6.5/c3.min.js\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 \

\i0 \cf6 The entry point for the code is about half way through this file, begining with the function:\
\pard\pardeftab720\partightenfactor0

\i \cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0     $(window).on('load', function () \{ \
        ...\

\i0 \cf6 In this function are the main calls to all the other javascript files.  In the case of the survey we call:\
\cf4     removeCookiesOnStartup();\
    getQuestions();\
    getOptions();\
    addClickHandlers();\
\cf6 and in the case of the charts we call:\
\cf4     displayCharts();\
    displayPieCharts();\
    displayScatterChart();\
    displayCheckboxData();\
    displayTableData();\
\cf6 All these functions can be found in the javascript files located in the client sub-directory.  The code then continues to set up the tabs for the application using the JQuery Tab widget (see: https://jqueryui.com/tabs/).  Most of these functionsrequest information from the server using AJAX calls.  JQuery provides a callback mechanism for such calls.  For example, the function getQuestions() in client.js makes the call:\
\pard\pardeftab720\partightenfactor0

\i \cf4     $.ajax(\
    \{\
        url: '/questions',\
        type: 'GET',\
        contentType:'application/json',\
        dataType:'json',\
        success: function(data) \{\
        	questions = data;\
        	results = new Array(questions.length);\
        \}	\
    \});\
\pard\pardeftab720\partightenfactor0

\i0 \cf6 The $ is alternative notation for the master JQuery object.  Here we are calling its ajax method.  The call takes one parameter: a JSON object, with several key-value pairs.  The url is the request that the server sees in the GET message.  If the server is happy with the request it will reply with a status code 200 (OK) and send back the requested data.  The client captures this data asynchronously in the function associated with the success key of the parameter used in the AJAX call.  To check the data returned from the server, put a breakpoint on the first line of this function and inspect the data variable.  Most of the other functions make similar calls and the data is always returned in the "success" function.\
\
Brief notes on some of these functions is given below:\
\
\pard\pardeftab720\partightenfactor0
\cf8 function removeCookiesOnStartup()\
\cf6 This function is used to remove the cookies used for auto-completing fiels.  If the browser gets refreshed to restart the application, without this function the browser will remember all the auto filled fields.  You can inspect cookies in most of the browsers.  For example in Chrome the Cookies tab can be found under Application/Storage.  The Application tab is usually the 5th tab (just after Network).  You google to see how to display cookies in other browsers.\
\cf8 \
function getQuestions()\
\cf6 Cleary this function gets all the questions from the server.  It also sets up an array to store all the results of the survey.\
\cf8 \
function getOptions()\
\cf6 This gets all the options from the surver and then calls displayQuestionsAndOptions().  This function does all the hard work; take a look at this fuction you'll see it contains a large if statement to cater for all the different types of questions (radio, textbox, text, textarea, ...).\
\pard\pardeftab720\partightenfactor0
\cf6 \
\pard\pardeftab720\partightenfactor0
\cf8 function displayCharts()\
\cf6 TBD\cf8 \
\
function displayPieCharts()\
\cf6 This function is similar to the others, except it needs to wait to load two different sets of data from the server: \cf4 '/piechart-data2'\cf6  and \cf4 '/piechart-questions-options'\cf6 .  Recall that all requests are asynchronous so I can't be sure in which order the requests will be received.  Therefore I store the result from these queries in 2 global variables:\
\pard\pardeftab720\partightenfactor0
\cf4     pieChartData = 
\b undefined
\b0 ;\
    pieChartQuestionsAndOptions = 
\b undefined
\b0 ;\
\pard\pardeftab720\partightenfactor0
\cf6 The variables are set to undefined initially, so that I can check when both are defined.  I have 2 callback functions (because there are 2 requests):\
\pard\pardeftab720\partightenfactor0

\b \cf4     function
\b0  getPieChartData(data) \{\
        pieChartData = data;\
        
\b if
\b0  (pieChartData && pieChartQuestionsAndOptions) \{\
            drawPieChart(data);\
        \}\
    \}\
\

\b     function
\b0  getPieChartQuestionsAndOptions(data) \{\
         pieChartQuestionsAndOptions = data;\
         
\b if
\b0  (pieChartData && pieChartQuestionsAndOptions) \{\
            drawPieChart(data);\
        \}\
    \}\
\pard\pardeftab720\partightenfactor0
\cf6 and I can't be sure which will fire last.  Hence I check for both global variables to be defined before proceding to call drawPieChart().\
\
\cf8 function displayScatterChart()\
\cf6 TBD\cf8 \
\
function displayCheckboxData()\
\cf6 TBD\cf8 \
\
function displayTableData()\
\cf6 TBD\cf8 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \
\

\f2 \cf0 \
}